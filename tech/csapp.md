### 1. 计算机系统漫游

处理器的指令集架构和微体系架构：

- 指令集架构描述每条机器代码指令的效果
- 微体系架构描述处理器实际的实现方式

几类存储器：

- 主存是由一组动态随机存取存储器（DRAM）组成
- 高速缓存是用静态随机访问存储器（SRAM）的硬件技术实现

OS是应用程序与硬件之间插入的一层软件：

- 虚拟机提供对整个计算机的抽象

- 进程是OS对一个正在运行程序的抽象，是对处理器、主存、I/O设备的抽象
- 指令集架构提供了对实际处理器硬件的抽象
- 虚拟内存为进程提供虚拟地址空间，使每个进程看到的内存都一致，是对主存和磁盘I/O设备的抽象
- 文件就是字节序列，是对I/O设备的抽象

并发、并行和超线程：

- 并发（concurrency）指的是一个同时具有多个活动的系统
- 并行（parallelism）指的是用并发来使一个系统运行得更快
- 超线程（hyperthreading）又称同时多线程，是一项允许一个CPU执行多个控制流的技术
- 超标量处理器（superscalar）：可达到比一个周期一条指令更快执行效率的处理器
- SIMD并行：一条指令产生多个可并行执行的操作，单指令、多数据

### 2. 信息的表示和处理

字节、字长、字节序：

- 大部分计算机都以8位（bits）的块作为最小的可寻址内存单位，称为一个字节（byte），在十六进制表示法下，一个字节的值域为`00-FF`

- 计算机的字长（word size）用来指明指针数据的的标称大小，字长的大小决定了虚拟空间地址的大小，对字长为$w$位的机器，虚拟地址的范围则为$0\sim2^{w-1}$，程序最多访问$2^w$个字节

- 很多对象都由多个字节组成，存储时要考虑它们的排列顺序，由此有了小端法（little endian）和大端法（big endian）两种规则：

  - 小端法：更低的有效位存放在更小的内存地址上
  - 大段法：更高的有效位存放在更高的内存地址上

- 当前大部分流行的OS都采用的小端模式，以下C代码可以打印各数据的字节表示：

  ```c
  #include <stdio.h>
  
  typedef unsigned char *byte_pointer;
  
  void show_bytes(byte_pointer start, int len) {
      size_t i;
      for (i = 0; i < len; ++i)
      	printf(" %.2x", start[i]);
      printf("\n");
  }
  
  int main() {
      int ival = 12345;
      float fval = (float) ival;
      show_bytes((byte_pointer) &ival, sizeof(ival));
      // Windows/Linux: 39 30 00 00 
      show_bytes((byte_pointer) &fval, sizeof(fval));
      // Windows/Linux: 00 e4 40 46
  }
  ```

- 文本数据比二进制数据更具有平台独立性，在使用ASCII码作为字符码的系统上都会有相同的结果

位级运算：

- 异或运算具有`a ^ a = 0`这样的性质，可以根据这个性质实现两个变量的原地交换：

  ```c
  #include <stdio.h>
  
  void inplace_swap(int *x, int *y) {
  	*y = *x ^ *y;
      *x = *x ^ *y;
      *y = *x ^ *y;
  }
  
  int main() {
      int x = 12306;
      int y = 12315;
      inplace_swap(&x, &y);
      printf("%d %d\n", x, y);
  }
  ```

整数表示：

- 原码（Sign-Magnitude）：最高有效位是符号位
  - 0有两种不同的表示
  - 进行加减运算复杂
- 反码（Ones' complement）：正数的反码等于原码，负数则等于原码除符号位外按位取反
  - 解决了原码中一个数加上其相反数不为0的问题：`B0001(1) + B1110(-1) = B1111(0)`
  - 0还是有两种表示方式，且负数相加会出错

- 补码（Two's complement）：最高有效位的权为负权（negative weight），正数的补码等于原码，负数的补码等于反码加一

- 原码、反码和补码的引入都是为了解决做减法的问题（计算机只有加法器），原码、反码表示法中化减法为加法的思维都是“减去一个数等于加上整个数的相反数”，而补码则是运用了模运算：对数值有限制、有溢出的运算来说，减去一个数等于加上这个数的同余数

  - `B0110(6) - B0010(2) = B0110(6) + B1110(14) = B1 0100(4)`

- 在C语言中，确定整型常量所属类型的规则在不同的标准上有所出入，由此32位有符号整数的最小值不能以`-2147483648`或`0x80000000`表示 ，而需要写为：

  ```c
  #define INT_MAX 2147483647
  #define INT_MIN (-INT_MAX - 1)
  ```

  - [C语言中TMin的写法 - 生栋 - 博客园 (cnblogs.com)](https://www.cnblogs.com/Jack47/archive/2013/01/06/TMin32-in-c.html)

- 要特别注意无符号数的使用，有符号数到无符号数之间的隐式转换会带来很多错误及漏洞，因此除C语言外很少有语言支持无符号整数









