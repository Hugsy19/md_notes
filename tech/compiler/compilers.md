## 1 引论

- 编译器的构造：

  - 编译器可看作一个能够把源程序映射为在语义上等价的目标程序的一个黑盒，该映射过程主要可分成两个部分：

    - 分析部分（analysis）：又称前端（front end），将源程序分解为多个部分，创建其中间表示，并收集源程序相关信息到符号表（symbol table）

    - 综合部分（synthesis）：又称后端（back end），根据中间表示和符号表信息来构造目标程序

  - 一个编译器的处理步骤一般可分为：

    - 词法分析（lexical analysis）：又称扫描（scanning），读入源程序字符流，输出形如<token, attri>的词法单元（token）

    - 语法分析（syntax analysis）：又称解析（parsing），根据词法单元创建语法树（syntax tree）

    - 语义分析（semantic analysis）：通过语法树和符号表信息，检查源程序是否和语言定义的语义一致

    - 中间代码生成：由源程序信息得到易于生成、且便于转换为目标程序的中间表示

    - 代码优化：试图改进中间代码，以生成更优的目标程序

    - 代码生成：将中间代码映射为目标程序

    - 符号表管理：记录源程序中使用的变量名，并收集其属性信息

  - 编译器的多个处理步骤可以组合到一起，称为趟（pass）

## 2 语法制导编译器

- 一个程序语言的

  - 语法（syntax）描述了该语言程序的正确形式

  - 语义（semantic）则定义了程序的含义，即其运行时所做的事情

- 语法定义

  - 文法定义

    - 描述语法的一种广泛方式是上下文无关文法（context-free grammer），其由四个元素组成：

      - 一个终结符号（terminal）集合：又称词法单元，是该语法所定义语言的基本符号的集合

      - 一个非终结符号（nonterminal）集合：又称语法变量，各非终结符号表示一个终结符号串的集合

      - 一个产生式（production）集合：一个产生式由三部分组成：

        - 产生式头/左部，是非终结符号

        - 一个箭头

        - 产生式体/右部，终结符号与非终结符号组成的序列，表示某个构造的某种书写方式

      - 指定某个非终结符号为开始符号

      - 例如：stmt -> if ( expr ) stmt else stmt

    - 上下文无关的含义是该语法中所有的产生式左边只有一个非终结符号

    - 从开始符号出发，推导得到的所有终结符号串的集合，称为该文法定义的语言

  - 语法分析树

    - 语法分析的任务是接受一个终结符号串作为输入，找出从文法的开始符号推导出这个串的方法

    - 对一个给定的上下文无关文法，其语法分析树（parse tree）具有如下性质：

      - 根节点为文法的开始符号

      - 各叶子结点为终结符号或空串（ε）

      - 各内部结点为非终结符号

      - 对某个内部结点A，其子节点为X1, X2...Xn，则必有产生式 A->X1X2...Xn

    - 一棵语法分析树的叶子结点，从左到右构建了树的推导结果

    - 一个文法可能具有二义性，可由多棵语法分析树生成同一个给定终结符号串，这种情况下续重新设计文法或用附加规则消除二义性

- 语法制导翻译

  - 语法制导翻译是通过向一个文法产生式附加一些规则或程序片段得到，与其相关的两个概念有：

    - 属性（attribute）：与某个程序构造相关的任意的量

    - 翻译方案（translation scheme）：一种将程序片段附加到一个文法的各个产生式的表示法

  - 语法制导定义（syntax-directed definition）将：

    - 每个文法符号和一个属性集合相关联

    - 每个产生式和一组语义规则（semantic rule）相关联

## 3 词法分析

## 4 语法分析

### 4.1 引论

文法：某种语言的语法规约

语法分析器：从此词法分析器获得一个由词法单元组成的串，并验证改串可由源语言的文法生成

处理文法的语法分析器大致可分为三类：

- 通用的：Cocke-Younger-Kasami算法、Earler算法
- 自顶向下的
- 自底向上的

通用方法的效率很低，一般不能用于编译器，最高效的自顶向下及自底向上方法都只能处理某些文法子类，且其中的**LL、LR文法**足以描述现代编程语言的大部分语法构造，手工实现的语法分析器常用LL文法，LR文法类的分析器则通常用自动化工具构造而成。

#### 错误恢复

检测到错误时，语法分析器可施行如下几种错误恢复策略：

- 恐慌模式恢复：不断丢弃输入的符号，直到找到通常为界限符的同步词法单元（synchronizing token）
- 短语层次恢复：对余下的输入进行局部纠正，需要小心选择替换方法以免死循环
- 错误产生式：在语言的语法中加入特殊产生式以应对常见错误

### 4.2 上下文无关文法

一个上下文无关文法的组成有：

- 终结符号：即词法单元，是组成串的基本符号
- 非终结符号：表示串的集合的语法变量，给出了语言的层次结构
- 开始符号：指定某个非终结符号而成，符合表示的串集合即为文法生成的语言，在文法中其产生式首先被列出
- 产生式：描述了将终结符号和非终结符号组合成串的方法，组成为：
  - 产生头/左部：非终结符号
  - 箭头
  - 产生式体/右部：零个或多个终结符合和非终结符号

把产生式看作重写规则，那么推导就是从开始符号出发，把一个非终结符号重写为它的某个产生式体的过程。用$\dot{\Rightarrow}$来表示可经过零步或多步推导出的关系，由此有以下几个概念：

- 句型（sentential form）：$S$为开始符号，且$S \dot{\Rightarrow} \alpha$，则$\alpha$为$S$的一个句型，$\alpha$中可存在终结/非终结符号，也可为空串
- 句子（sentence）：不包好非终结符号的句型
- 语言（language）：一个文法生成语言是它的所有句子的集合
- 上下文无关语言（context-free language）：可通过文法生成的语言

根据推导过程中的替换顺序，可分为：

- 最左推导：替换时总选择每个句型的最左非终结符号，写作$\alpha \dot{\underset{lm}\Rightarrow} \beta$
- 最右推导：替换时总选择每个句型的最右非终结符号，写作$\alpha \dot{\underset{rm}\Rightarrow} \beta$

语法分析树是推导的图形化表示形式，它过滤了推导过程中对非终结符应用产生式的顺序，因此语法分析树和最左/最右推导之间存在一对一的关系。如果一个文法可以为某个句子生成多棵语法分析书，则该文法具有**二义性**（ambiguous）。

文法是比正则表达式表达能力更强的表示方法，可以使用正则表达式描述的构造都能用文法来描述，反之则不然，即每个正则语言都是一个上下文无关语言。

### 4.3 设计文法

正则表达式描述的东西都可以由文法描述，但还是用正则表达式来定义一个语言的词法语法的原因：

- 将语言的语法结构分为词法和非词法两个部分，而更容易将编译器的前端模块化
- 语言的词法规则通常都很简单，不必大材小用，正则表达式描述的词法不仅简洁易懂，自动机构造的分析器效率也高于任意文法分析器

不是所有的语法构造都能通过文法进行描述，例如C语言中的标识符先声明后使用、函数调用时参数个数的正确性，这些都要放到语义分析阶段去检查。

#### 消除二义性

一个二义性文法有时可以被改写为无二义性的文法，例如下面的”悬空-else“文法：
$$
stmt \to \text{if}\ expr\ \text{then}\ stmt\ |\ \text{if}\ expr\ \text{then}\ stmt\ \text{else}\ stmt\ |\ \text{other}
$$
改写为无二义性的文法如下：
$$
stmt \to matched\_stmt\ |\ open\_stmt\\
matched\_stmt \to \text{if}\ expr\ \text{then}\ matched\_stmt\ \text{else}\ matched\_stmt\ |\ other\\
open\_stmt \to \text{if}\ expr\ \text{then}\ stmt\ |\ \text{if}\ expr\ \text{then}\ matched\_stmt\ \text{else}\ open\_stmt\\
$$

#### 消除左递归

对于一个**立即左递归**的产生式：
$$
A \to A\alpha\ |\ \beta
$$
可以通过以下转换将左递归变成右递归：
$$
A \to \beta A^{’} \\
A^{’} \to \alpha A^{’}\ |\ \epsilon
$$
例如下面是几个指明运算符结合性和优先级的LR文法：
$$
E \to E + T\ |\ T \\
T \to T * F\ |\ F \\
F \to (E)\ |\ id
$$
把$+ T$、$* F$都看成一个整体，消除左递归得到：
$$
E \to TE^{'} \\
E^{'} \to +\ TE^{'}\ |\ \epsilon \\
T \to FT^{'} \\
T^{'} \to *\ FT^{'}\ |\ \epsilon \\
F \to (E)\ |\ id
$$
对于非立即左递归，则先归化为立即左递归，再按上述方式消除。例如：
$$
S \to Aa\ |\ b \\
A \to Ac\ | Sd\ |\ \epsilon \\
$$
先进行归化：
$$
A \to Ac\ | Aad\ |bd\ |\ \epsilon \\
$$
之后消除左递归结果如下：
$$
S \to Aa\ |\ b \\
A \to bdA^{’}\ | A^{’} \\
A^{’} \to cA^{’}\ | adA^{’}\ | \epsilon
$$

#### 提取左公因子

作为一种文法转换方法，提取左公因子可以产生适用于预测分析技术或自顶向下分析技术的文法。当某个产生式存在多个选择时，可以通过此方法改写产生式，以将决策时间推后，等有了足够多的输入获取了足够多的信息再行决定。

提取方法：

- 对于每个非终结符号$A$，找出它的两个或多个选项之间的最长公共前缀$\alpha$：$A^{’} \to \alpha A^{’}\ |\ \gamma$
- 用新的非终结符号$A^{'}$来表示非公共的部分的转换：$A^{'} \to \beta_{1}\ |\beta_{2}\ |...|\beta_{n}$

### 4.4 自顶向下的语法分析

自顶向下的语法分析相当于为输入串构造语法分析树的过程，以开始符号为树的根节点，按先根次序创建树的各个结点。自顶向下的语法分析也可以看作是寻找输入串的最左推导的过程。



